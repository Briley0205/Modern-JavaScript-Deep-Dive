## 📕 오늘 읽은 내용, 이런 식으로 정리해 봅시다. ✒

**TIL(Today I learn) 기록일** : 2022.07.06

**오늘 읽은 범위** : 4장 변수

### 메모리에 붙이는 꼬리표, 변수(식별자) 📑

---

### 변수란?

- 4.1 변수란 무엇인가? 왜 필요한가?
  - 변수는 프로그래밍 언어에서 데이터를 관리하기 위한 핵심 개념
  - 그러다면 변수는 왜필요할까?? 
  - 먼저 10 + 20 을보면 인간은 모두 두뇌에서 계산과 기억을 동시에하지만 컴퓨터는 연산과 기억을 수행하는 부분이 나눠져있다.
  - CPU는 계산을 메모리는 기억을 한다
    - 그렇다면 메모리는 무엇일까?
      - 메모리는 데이터를 저장할 수 있는 메모리 셀의 집합체이다.
      - 메모리 셀 한의 크기는 1바이트(8비트)이며, 이 1바이트 단위로 데이터를 저장(write)하거나 읽어(read)들인다.
      - 각 셀은 고유의 메모리 주소를 갖는다 (메모리 주소는 메모리 공간의 위치를 나타내며, 0부터시작해서 메모리의 크기만큼 정수로 표현된다. 예를 들어 4GB메모리는 0부터 4,294,967,295 [0x00000000~ 0xffffffff]까지의 메모리 주소를 갖는다.
  - 그럼 20 + 30을  메모리가 기억할려고할때 어떤상활이 벌어질까?
    - 컴퓨터는 모든 데이터를 2진수로 처리하기에 메모리에 저장되는 데이터는 데이터의 종류와 상관없이 모두 2진수로 저장된다.
    - 위 예제의 숫자 값 10과 20은 메모리 상의 임의의 위치(메모리 주소)에 기억(저장)되고 CPU는 이 값을 읽어들여 연산을 수행한다.
    - 연산 결과로 생선된 숫자 값 30도 메모리 상의 임의의 위치에 저장된다. 
    - 그런데 여기서 문제가 있다. CPU가 연산해서 만들어낸 숫자 값 30을 재사용할 수 없다는 것이다. 
    - 연산 결과를 단 한 번만 사용한다며 문제가 없겠지만 만약 연산 결과 30을 재사용하고 싶다면 메모리주소를 통해 연산 결과 30이 저장된 메모리 공간에 직접 접근하는 것 외에는 방법이 없다.
    - 하지만 메모리 주소를 통해 값에 직접 접근하는 것은 치명적 오류를 발생시킬 가능성이 높은 매우 위험한 일이다.
    - 만약 실수로 운영체제가 사용하고 있는 값을 변경하면 시스템을 멈추게 하는 치명적인 오류가 발생할 수도 있다.
    - 따라서 자바스크립트는 개발자의 직접적인 메모리 제어를 허용하지 않는다.
    - 만약 자바스크립트가 개발자의 직접적인 메모리 제어를 허용하더라도 문제가 있다.
    - 값이 저장될 메모리 주소는 코드가 실행될 때 메모리의 상황에 따라 임의로 결정된다. 따라서 동인한 컴퓨터에서 동인한 코드를 실행해도 코드가 실행될 때마다 값이 저장될 메모리 주소는 변경된다.
    - 이처럼 코드가 실행되기 이전에는 값이 저장된 메모리 주소를 알 수 없으며, 알려 주지도 않는다. 따라서 메모리 주소를 통해 값에 직접 접근하려는 시도는 올바른 방법이 아니다.
  - 위와 같은 문제점을 해결하기위해 프로그래밍 언어는 기억하고 싶은 값을 메모리에 저장하고, 저장된 값을 읽어 들여 재사용하기 위해 변수라는 메커니즘을 제공한다. 
  - 결국 변수란?  하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름을 말한다
  - 왜? 이렇게 하지 않으면 결과값을 제사용하기 위해 메모리 주소를 직접 접근하다 치명적 오류가 발생할 수도 정확한 메모리 주소도 알기 힘드니까
  - 한마디로 값의 위치를 가리키는 상징적인 이름이 바로 '변 수 '이다.
    - 이렇게 변수를 통해 저장된 값을 참조하는 것이 개발자가 직접 메모리 주소를 통해 값을 저장하고 참조하는 번거로움과 위험을 해소시켜준다.
  - 변수에 값을 저장하는 것을 할당(대입,저장)이라하고 변수에 저장된 값을 읽어 들이는 것을 참조라 한다.
  - 변수에 여러 개의 값을 저장하는 방법
    - 변수는 하나의 값을 저장하기 위한 메커니즘이다. 여러 개의 값을 저장하려면 여러 개의 변수를 사용해야 한다. 단, 배열이나 객체 같은 자료구조를 사용하면 여러 개의 값을 그룹화해서 하나의 값처럼 사용가능 
  
  
- 4.2 식별자
  - 변수 이름을 '식별자'라고도 한다.
  - 실벽자는 어떤 값을 구별해서 식별할 수 있는 고유한 이름을 말한다.
  - 식별자는 값이 저장되어 있는 메모리 주소와 매핑 관계를 맺으며, 이 매핑 정보도 메모리에 저장되어야 한다. 이처럼 식별자는 값이 아니라 메모리 주소를 기억하고 있다.
  - 식별자로 값을 구별해서 식별한다는 것은 식별자가 기억하고 있는 메모리 주소를 통해 메모리 공간에 저장된 값에 접근할 수 있다는 의미다. 즉 식별자는 메모리 주소에 붙인 이름이라고 할 수 있다.
    - ex)    result       0x0669f913        30
    -     변수이름(식별자)      메모리 주소       메모리 
  - 식별자라는 용어는 변수 이름에만 국한해서 사용하지 않는다. 예를 들어 함수, 변수, 클래스 등의 이름은 모두 식별자이다.     
  
   

</br>

> 값이 저장될 메모리 주소는 코드가 실행될 때 메모리 상황에 따라 임의로 결정된다.
같은 컴퓨터, 같은 프로그램이라 하더라도, <strong>매번 실행될 때마다 다른 메모리에 저장</strong>된다.</br> 때문에 메모리 주소를 통해 값에 직접 접촉하려 하는 것은 무모하다.</br>
그래서 평가 결과값을 저장하고, 참조하기 위해 값의 위치를 가리키는 상징적인 이름을 붙여 관리한다.

---

### 변수 생성 시 일어나는 과정

</br>
JS엔진이 변수 키워드를 발견하면,

1. 값을 저장하기 위한 메모리 공간을 확보
2. 변수 이름과 메모리 공간의 주소를 연결
3. 변수 이름을 실행 컨텍스트에 등록
4. 메모리 공간에 undefined를 할당해 초기화

하는 과정을 거친다.

> 초기화 단계를 거치는 이유 ?
메모리 공간을 확실히 비워놓기 위해 초기값을 설정한다.</br>
그렇지 않으면, 이전에 실행한 다른 앱에서 남겨진 값(쓰레기 값)이</br>
아직 메모리에 남아있을 가능성이 있기 때문이다.

---

### JS는 코드 실행을 위한 평가 과정을 거친다

</br>
변수 선언은, 런타임이 아닌, 평가 단계에서 먼저 실행된다.</br>
JS는 코드를 실행하기에 앞서 소스코드 평가 과정을 거친다.</br>
바로 이 단계에서, 모든 선언문을 찾아 먼저 실행해 놓는다.</br> 
때문에 (var의 경우)변수 선언이 어느 라인에 위치하든,</br> 
어디서든 변수를 참조할 수 있다.</br>
(const, let은 이를 용납하지 않는다.)

var : undefined</br>
const, let: RefrenceError

> 값의 할당 시점
모든 선언문은 평가 단계에서 먼저 실행된다.</br>
하지만 값의 할당은 런타임에 이루어진다.</br>

또한, JS 엔진은 변수의 선언(등록)과 값의 할당을</br>
2개의 문으로 나누어 하나씩 실행한다.</br>
때문에 변수에 undefined를 할당하고 초기화 시킨다는 것은 변함없다.

> 값의 재할당
이미 선언된 변수에 값을 재할당 하면, 처음 할당했을 당시</br>
확보했던 메모리에 저장된 값을 수정하는 것이 아니라,</br>
또다른 메모리 공간을 확보한 후, 그 메모리 공간에 새로운 값을 저장한다.</br>

그리고 이전 값은 어떤 변수와도 연결되어 있지 않은 상태가 된다.</br>
어떤 식별자와도 연결되어 있지 않은 값은 불필요해 진다.</br>
따라서 이러한 값들은 가비지 콜렉터에 의해 메모리에서 해지된다.

---

### 단어장 🔖
```
 할당(대입, 저장): 변수에 값을 저장함
 매핑: 하나의 값을 다른 값으로 대응시키는 것
 변수 호이스팅: 변수 선언문이 코드의 맨 앞줄로 끌어올려진 것처럼
 동작하는 것.
 가비지 콜렉터: 메모리 공간을 주시하며 더 이상 사용되지 않는
 메모리의 값을 헤제하는 기능.
```

### 궁금한 내용이나, 더 알아보고 싶은 내용을 적어봅시다 🤔
```
선언된 모든 식별자가 호이스팅된다.
그럼, 이건 왜 그럴까
var 의 경우:
console.log(score); --> undefined
var score;
const, let의 경우:
console.log(score); --> ReferenceError(참조 에러)
const(or let) score = 1;
var, const, let이 실행 전 평가 단계에서 먼저 실행되고,
초기값을 undefined로 받으며, 호이스팅 된다면,
왜 모두 undefined로 출력되는 것이 아니라,
const, let에서는 참조 에러가 나는 것일까 ?
이유는, TDZ(temporal dead zone) 때문이다.
TDZ는 const와 let, class의 유효성을 관리한다.
따라서 선언 전에 변수에 접근하는 것을 금지하며,
변수 선언 전에는 그 어떠한 기능도 사용할 수 없다.
전자의 경우, const(or let) score = 1; 구문 전 줄 까지
score 변수는 TDZ에 들어있기 때문에 
선언 전에 변수를 호출하지 못하는 것이다.
```

---

### 다른 분이 작성하신 TIL에 대한 소감
