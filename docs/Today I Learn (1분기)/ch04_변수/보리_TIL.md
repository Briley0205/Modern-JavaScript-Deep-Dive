## 📕 오늘 공부한 내용, 이렇게 정리해 봅시다. ✒

**TIL(Today I learn) 기록일** : 2022.07.06

**오늘 읽은 범위** : 4장 변수

### 변수란 ?

+ 변수는 값을 저장하는 공간, 자료를 저장할 수 있는 이름이 주어진 기억 장소라고도 한다.
+ 어떠한 계산식이 있을 경우, 인간은 보이는 그대로 숫자와 연산을 이용해 결과값까지 두뇌에 기억한다.
+ 컴퓨터는 연산과 기억을 따로한다. CPU를 이용해 연산하고, Memory를 통해 데이터를 기억한다.
  - 메모리 : 데이터를 저장할 수 있는 메모리 셀의 집합체 !
    - 메모리 셀 하나의 크기 : 1byte(1bit), 1byte단위로 데이터를 저장하거나 읽어들임.
    - 각 셀은 고유의 메모리 주소를 갖는다. ex : 0x000000F2 <- 이 주소로 값이 저장됨!
    - 식을 마친 결과값을 한번만 사용하면 문제없지만, 재사용 하고 싶다면, 메모리주소를 통해 저장공간에 직접 접근하는 방법 뿐!
    - 하지만, 치명적 오류를 발생시킬 가능성이 높기에, JS는 우리에게 직접적인 메모리 제어를 허용하지 않음!!
    - 그래서 "변수" 라는 매커니즘을 제공!

### 식별자란 ?

+ 변수이름을 식별자 라고도 함
+ 어떤 값을 구별해서 식별할 수 있는 고유한 이름
  - 이게 메모리 주소마다 값이 있는데, 주소가 너무 길어서 변수이름을 사용한다.
  - 즉, 변수이름은 값이 아니라 메모리 주소를 기억하고 있는 것!!


### 변수선언 ?

+ 변수를 생성하는 것을 말함.
+ 값을 저장하기 위한 메모리 공간을 확보하고, 변수이름과 확보된 메모리 공간의 주소를 연결해서 값을 저장할 수 있게 준비하는것!
+ 변수를 사용하려면 반드시 선언이 필요하다 ! -> var,let,const 키워드 사용 ! (let,const는 ES6부터 도입)
  - var 는 여러 단점이 있다.
  - 블록레벨 스코프를 지원하지 않고, 함수레벨 스코프를 지원한다.
  - 의도치 않게 전역 변수가 선언되어 심각한 부작용이 발생하기도 한다! 그래서 let, const가 탄생!

### 변수선언의 실행 시점과 변수 호이스팅
```js
console.log(score);
var score;
```
+ undefined 가 출력된다.
  - 이유는 : 변수선언이 소스코드가 한 줄씩 순차적으로 실행되는 시점, 즉 런타임이 아니라 그 이전 단게에서 먼저 실행되기 때문이다!
  - 이처럼 변수 선언문의 코드의 선두로 끌어 올려진 것처럼 동작하는 JS고유의 특징을 "변수 호이스팅"이라고 한다!

### 값의 할당

+ 변수에 값을 할당할 때는 = 을 사용한다.
```js
var score; //변수선언
score = 100; //값의할당
//변수선언과 값의 할당을 하나의 "문"으로 단축가능 !
var score = 100;
```
+ 여기서 주의! 
+ 변수선언은 소스코드가 순차적으로 실행되는 시점인 런타임 이전에 먼저 실행되지만, "값의 할당"은 소스코드가 순차적으로 실행되는 시점인 "런타임"에 실행된다.
```js
//예를 들어보자.
console.log(score); //undefined

var score; //1.변수선언
score = 100; //2.값의할당
console.log(score); //100

//1.변수선언은 런타임 이전에 먼저 실행되고, 2.값의할당은 런타임에 실행된다.
//그래서 2.값을 할당할 때는, 이미 1.번이 실행되어 undefined로 초기화 되어있다.
```

### 값의 재할당

+ 이미 값이 할당되어 있는 변수에, 새로운 값을 또다시 할당하는 것을 말함!
+ var과 let은 가능하지만 상수(const)는 변경할 수 없다.

---

### 책속 한구절 보관함 📖

| p    | text                                           |
| ---- | ---------------------------------------------- |
| 46   | 변수에 값을 재할당 하면, 값이 저장되어 있는 메모리 공간이 지워지는 것이 아니라, 새로운 메모리 공간을 확보하고 그 메모리 공간에 값을 저장하는것이다.


### 궁금한 내용이나, 더 알아보고 싶은 내용을 적어봅시다 🤔
```
const상수는 재할당 할 수 없다는것을 정확히 이해했지만, let과 var의 차이에 대해 더 알고 싶어 공부를 했다.
일단 var가 먼저 나왔고, ES6에 let이 뒤늦게 탄생했다 ! 문제가 있었기 때문에 탄생한 것이다!

예를 들어보겠다.
console.log(a); //undefined
var a = 1;
console.log(a); //1
//책에서도 봤지만 호이스팅때문에 에러가 뜨지 않는다. 
//a를 JS엔진이 미리 저장해둔다. 1로 할당하기 전이기 때문에 undefined가 호출!
--------------------------------------------------------------
console.log(a); //undefined
a = 1;
var a;
console.log(a); //1 -> 이것또한 위와 같음!
--------------------------------------------------------------
function a(){
  var b = 1;
}
console.log(b); //error
//지역변수는 {}블럭안에서 선언된 변수를 이야기하고, {}블럭안에서만 사용가능하다.
//에러가 출력되는게, 즉 var은 함수만 지역변수로 호이스팅되고, 나머지는 다 전역변수로 올려버린다. 그래서 function에서는 오류가 뜬다.
--------------------------------------------------------------
for(var i = 1; i < 5; i++){
  console.log(i); //1234
}
console.log(i); //12345
//for은 역시 전역변수로 호이스팅하므로 오류가 뜨지않는다.
--------------------------------------------------------------
var a = 1;
console.log(a); //1
var a = 2;
console.log(a); //2
//변수이름이 같아도 error이 안뜬다. 이것이 바로 var의 큰 단점! 그래서 let 이 탄생했다 !
--------------------------------------------------------------
위에 오류가 뜨지 않는 var들을 let으로 바꾸면 모두 error가 출력된다.
그렇다고 let이 호이스팅이 안돼서 그런것이 아니다. let또한 호이스팅이 된다!
하지만 let은 TDZ(Temporal Death Zone) 개념이 있다.
a가 호이스팅으로 기억이 되어 있지만, a선언문이 나오기 전까지는 접근 할 수 없게 되어있다.
일시적으로 death zone이 된것이다. 그래서 a에 접근 할 수 없다는 error이 출력되는것 !

```

---

### 다른 분이 작성하신 TIL에 대한 소감
- 많이 공부했습니다. 저도 아직 예를 들거나 혼자공부한 내용이 많이 부족하지만, 누군가 읽으시고 도움이 됐다면 정말 기쁠 것 같습니다 (__)
- 모두가 인간JS가 되는 그날까지.... !
