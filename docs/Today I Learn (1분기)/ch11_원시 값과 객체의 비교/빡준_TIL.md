## 📕 오늘 공부한 내용, 이렇게 정리해 봅시다. ✒

**TIL(Today I learn) 기록일** : 2022.07.21

**오늘 읽은 범위** : 11장 원시 값과 객체 비교 11.1 ~ 11.2

### 원시타입

```
변경 불가능한 값

변수에 할당하면 변수에는 실제 값이 저장된다

다른변수에 할당하면 원본의 원시 값이 복사되어 전달된다. 이를 값에 의한 전달이라 한다.
```

### 객체타입

```
타입의값, 변경 가능한값

변수에 할당하면 변수에는 참조 값이 저장된다.

다른변수에 할당하면 원본의 참조 값이 복사되어 전달된다. 이를 참조에 의한 전달이라 한다.
```

## 원시 값

### 값을 변경할 수 없다는 것이 구체적으로 무엇일까?

```
변수와 값은 구분해서 생각해야 하는데, 변수는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름이고,
값은 변수에 저장된 데이터로서 표현식이 평가되어 생성된 결과를 의미한다.

즉 변경이 불가능하다는 것은 변수가 아니라 값에 대한 진술이다.

원시값을 변경할 수 없다 === 원시값 자체를 변경할 수 없다
원시값을 변경할 수 없다 !== 변수값을 변경할 수 없다
```

상수

```
상수는 재할당이 금지된 변수이다
```

> 원시값을 할당한 변수에 새로운 원시값을 재할당하면 메모리 공간에 저장되어있는 재할당 이전의 원시값을 변경하는 것이 아닌!! \
> 새로운 메모리 공간을 확보하고 재할당한 원시 값을 저장한후 변수는 새롭게 재할당한 원시 값을 가리키게 된다.

### 불변성을 갖는 원시값을 할당한 변수는 재할당 이외에 변수 값을 변경할 수 있는 방법이 없다

문자열과 불변성

```
C에서는 문자를 위한 데이터 타입(char) 만있고 문자열 타입은 존재하지않고,문자열을 문자의 배열로 처리한다.
Java에서는 문자열을 String 객체로 처리한다.

하지만 JS에서는 원시타입의 문자열 타입을 제공하는데, 이는 원시 타입이며, 변경 불가하다.
```

```ts
var str = "HELLO";
str = "WORLD";
```

첫번쨰 문이 실행되면 문자열 'HELLO'가 생성되고, 식별자 str은 문자열 'HELLO'가 **저장된 메모리 공간의 첫번째 메모리 셀 주소**를 가리킨다.

두번쨰 문이 실행되면 **이전에 생성된 문자열 'HELLO'를 수정하는것이 아닌** 새로운 문자열 'WORLD'를 메모리에 생성하고 식별자 str은 이것을 가리키게 된다.

'HELLO'와 'WORLD'는 모두 메모리에 존재한다. 식별자 str이 'HELLO'에서 'WORLD'를 가르키는것으로 변경되었을 뿐이다.

문자열은 유사배열 객체 이며 이터러블 이므로 배열과 유사하게 문자에 접근할수있다.

```js
var str = "string";

console.log(str[0]); // s

str[0] = "n";

console.log(str); // string
```

문자열은 유사 배열이므로 인덱스를 이용해 각 문자에 접근은 가능하지만, 문자열은 원시 값이므로 변경할 수 없다.

하지만 변수에 새로운 문자열을 할당하는것은 물론 가능하다. 이는 식별자가 기존 문자열을 가르키는것이 아닌 새로운 문자열을 가르키는것이기 때문이다.

### 값에 의한 전달

> 변수에 다른 변수의 값을 전달하는 형태를 뜻한다.

ECMA script 사양에는 변술르 통해 메모리를 어떻게 관리해야하는지 명확하게 정의되어 있지않기때문에

각 브라우저의 엔진마다 미묘하게 다를수있다.

염격히 말해서
"값에의한 전달"은 JS를 위한 용어가 아니므로 오해가 있을수있다.
변수에는 값이 전달되는것이 아닌 메모리 주소가 전달되기 때문이다. 이는 변수와 같은 식별자는 값이 아니라 메모리 주소를 기억하고 있기 때문이다.

## 객체

객체는 복합적인 자료구조이므로 객체를 관리하는 방식이 원시 값과 비교ㅗ해서 복잡하고 구현 방식도 브라우저 제조사마다 다를 수있다.

객체는 원시값과 다른 방식으로 동작하도록 설계되어있다.

**객체는 참조값** 즉 변경 가능한 값이다.

원시 값을 할당한 변수가 기억하는 메모리 주소를통해 메모리 공간에 접근하면 원시 값에 접근 할수있다. 원시값을 할당한 변수는 원시 값 자체를 값으로 갖는다.

하지만 객체를 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 **참조값**에 접근할 수 있다. (참조 값은 생성된 객체가 저장된 메모리 주소 그 자체다)

```js
var person = {
  name: "bbakjun",
};
```

위와같이 객체 변수를 생성했다고하자

person 이라는 식별자가 0x000000F2 의 메모리 주소에
{
name : 'bbakjun'
}
를 저장하고있는 0x00001332 메모리 주소를 값으로 가지고있게 된다.

일반적으로 원시값을 할당한 변수의 경우
변수는 X값을 갖는다 또는 변수의 값은 X다 라고 ㅛ현한다

하지만

객체를 할당한 변수의 경우 변수는 객체를 참조하고있다. 또는 변수는 객체를 가리키고 있다 라고 표현한다.

위에서 person 변수는 객체
{
name : 'bbakjun'
}
를 가리키고(참조하고) 있게 된다.

```js
person.name = "Jay";

person.age = 27;

console.log(person);
// { name : 'Jay', age : 27 }
```

객체는 재할당 없이 프로퍼티를 동적으로 추가할 수도 있고 프로퍼티 값을 갱신할 수도있고 삭제할 수도있다.

앞서 객체를 할당한 변수는 메모리 값에 객체를 저장하므로, 객체를 직접 수정할 수 있다.

이때 객체를 할당한 변수에 재할당 한것은 아니므로 객체를 할당한 변수의 "참조값"은 변하지 않는다.

> 참조에 의한 전달

```js
const person = {
  name: "bbakjun",
};

const copy = person;
```

객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달된다. 이를 참조에 의한 전달(얕은 복사)라고 한다.

person과 copy 변수의 메모리 주소값은 다르다
하지만 같은 메모리값을 가지게된다. 바로 { name : 'bbakjun' } 이라는 객체를 저장한 메모리 주소값을 가지게된다

이것은 두개의 식별자가 하나의 객체를 공유한다는 의미하는데 따라서 원본 또는 사본 중 어느 한쪽에서 객체를 변경하면 영향을 받게 된다.
(변수에 새로운 객체를 재할당 하는것이 아닌 객체의 프로퍼티 값을 변경하거나 프로퍼티를 추가 삭제)

### 떠오르는 생각이 있었니요? 나의 사색을 기록해 봅시다 💭

오늘 테오의 프론트엔드 오픈카톡방에서 spread operator를 사용한 할당의 경우 얕은복사가 맞는가에대한 질문이 올라왔었다

나는 얕은 복사인것은 알고있었는데, 자세하게는 까먹고있어서 답을 못했었다...
하지만 마침 오늘 원시값과의 비교라는 챕터의 TIL을 작성하는 날이어서 다행이었다.

```js
const obj = { label: "라벨", value: null };
const newObj = { ...obj };
```

<div style="display:flex;">
<img
  src="https://velog.velcdn.com/images/wnsguddl789/post/e9b931d3-0ac8-4485-80a5-c414e9fd8b01/image.png"
  width="200"
  height="400"
/>

<img
  src="https://velog.velcdn.com/images/wnsguddl789/post/e867a975-fe45-4915-95cd-bd98f15300f7/image.png"
  width="200"
  height="400"
/>

<img
  src="https://velog.velcdn.com/images/wnsguddl789/post/9e7b5be4-562b-4297-b445-4c79d7f71898/image.png"
  width="200"
  height="400"
/>

</div>
