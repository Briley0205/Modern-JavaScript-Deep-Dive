## 📕 오늘 공부한 내용, 이렇게 정리해 봅시다. ✒

**TIL(Today I learn) 기록일** : 2022.09.10 - 11

**오늘 읽은 범위** : 39장 DOM

### Document Object Model 📑

- DOM을 조작한다 할때 그 DOM. 리액트는 가상돔을 쓰고, 돔을 직접 조작하면 리플로우와 리페인트가 일어나서 그러지 않는게 좋지만 종종(자주) 직접 조작 해야 하는 경우가 발생한다. DOM의 개념과 여러가지 조작 방법을 알아두는게 좋다.

---

### DOM 📑

- 돔은 HTML 문서의 계층적 구조와 정보(프로퍼티) + 제어용 API(메서드)로 구성된 트리 형태의 자료구조이다.

- HTML 문서는 렌더링 엔진에 의해 파싱되어 돔을 구성하는 요소(앨리먼트)노드 객체로 변환된다. 이때 HTML 문서를 구성하는 HTML 요소들은 객체화 + 중첩으로 인한 계층적인 부자관계가 형성된다.

- 트리 자료구조는 부모노드, 자식노드로 구성되어 노드간의 계층적 구조를 표현하는 비선형 자료구조를 얘기한다. 모든 트리는 하나의 최상위 노드(루트노드)에서부터 시작된다.

- 돔 트리 : 트리 자료구조로 되어있다는 특징 때문에 DOM을 DOM트리라고 부르는 사람도 많다.

### 노드 타입 📑

- 노드에는 12가지 종류가 있다. 그 중 자주쓰는 건 5가지.

1. Document 노드 : 딱 하나 있는 최상위노드

2. element 노드 : 요소 노드. 요소간의 중첩에 의해 부자관계를 가지게 되며 이 부자관계를 통해 정보는 구조화된다. 문서의 구조를 표현하는 노드라고 할수 있다.

3. 어트리뷰트 노드 : 어트리뷰트 노드는 앨리먼트 노드에만 연결되어 있는 전용 노드이다. 앨리먼트 노드에 직접 연결되어 있지만 앨리먼트가 부모는 아니다, 그치만 따로 부모노드가 있는 것도 아니라서 앨리먼트와 형제도 아니다. 그림자 같은 거다. 어트리뷰트에 접근하기 위해서는 앨리먼트 노드에 먼저 접근해야 한다.

4. 텍스트 노드 : 컨텐츠(텍스트)를 가리키는 객체다. 문서의 정보를 표현하며 돔트리의 최종단에서 컨텐츠를 보여주는 용도이다. 부모로 앨리먼트를 가지며 자식노드를 가질 수 없는 리프노드이다. 텍스트에 접근하기 위해서는 앨리먼트에 먼저 접근해야 한다.

5. 프래그먼트 노드 : 리플로우 리페인트를 줄이려면 돔 요소의 변경을 줄여야 한다. 그 방법으로 가장 좋은 건 부모노드를 하나 만들어서 그 안에 담는 것이다. 노드 1개로 취급되니까. 이 방법의 단점은 필요없는 부모노드가 하나 생성되어야 하는 건데 이때 프래그먼트를 쓰면 노드들을 묶는데 사용하면서도 돔트리가 필요없는 노드를 굳이 인식하지 않게 할수가 있다.

### 토막상식

- 돔을 구성하는 노드 객체는 자신의 구조와 정보를 제어할 수 있는 돔 API를 사용할 수 있다.

- 돔을 구성하는 노드 객체는 표준 빌트인 객체가 아닌 브라우저에서 제공하는 호스트 객체이다.

- 돔을 구성하는 노드 객체 또한 자바스크립트 객체이기에 프로토타입에 의한 상속구조를 갖는다. 프로토타입 체인에 있는 모든 프로퍼티와 메서드를 상속받아 사용할 수 있다.

- 각 노드 객체의 상속구조는 개발자도구의 앨리먼트 탭 -> 프로퍼티스 패널을 보면 확인할 수 있다.

- DOM API : 문서 객체 모델 애플리케이션 프로그래밍 인터페이스의 약자

- 프론트엔드 개발자는 HTML을 사용할때 단순히 태그와 어트리뷰트를 선언적으로 배치하여 뷰를 짜는게 아니라 DOM 트리의 구조를 이해하고 좀더 효율적으로 HTML 문서를 구성하기 위해 노력해야 한다.

### 요소 노드 취득법

1. ID : getElementId로 아이디를 가져온다. 아이디는 하나만 존재할 수 있지만 여러개 있더라도 딱히 오류가 뜨는건 아니므로 잠재적으로 같은 아이디값을 갖는 앨리먼트가 여러개 존재할 수는 있다.

- 그 경우 찾아낸 것중 첫번째 노드 하나만 반환한다.

- 앨리먼트에 아이디를 부여하면 아이디 값과 동일한 이름의 전역 변수가 암묵적으로 선언되고 해당 노드 객체가 할당된다.
- 그러나 앨리먼트의 아이디와 명시적으로 선언된 전역변수의 아이디가 같으면 항상 전역변수가 우선되며 전역변수를 가리키는 아이디는 앨리먼트에 재할당되지 않는다.

2. 태그네임 : getElementsByTagName으로 인수로 전달한 HTML태그 이름을 가진 모든 앨리먼트 노드들을 탐색하여 HTMLCollection 객체로 반환한다.

- HTMLCollection 객체는 유사 배열 객체이면서 이터러블이다.
- 인수에 \*를 넣으면 와일드카드가 된다.
- 중첩으로 검색할 수 있다.

```js
const $fruit = document.getElementById("fruit");
const $lisFromFruit = document.getElementsByTagName("li");
// 프루트 아이디 태그를 가진 애들의 자식노드 중에서 태그 이름이 li인 것만 찾아 반환한다.
```

- 조건에 맞는걸 못찾을때는 빈 객체를 반환한다.

3. class : getElementsByClassName으로 인수로 전달한 것과 매칭되는 클래스 어트리뷰트를 가진 가진 모든 앨리먼트 노드들을 탐색하여 HTMLCollection 객체로 반환한다.

- 클래스네임 어트리뷰트는 공백으로 구분하여 여러개를 지정할 수 있고 검색할때 인수 전달 또한 공백으로 구분하여 여러개를 다 충족하는 객체를 부를 수 있다.
- HTMLCollection 객체는 유사 배열 객체이면서 이터러블이다.
- 중첩으로 검색할 수 있다.

4. css 선택자를 이용한 요소 노드 취득

- css 셀렉터로도 노드를 특정할수가 있다.
- 전체선택자(\*), 태그이름 선택자, 아이디 선택자, 클래스이름 선택자, 어트리뷰트 선택자(태그가 가지는 클래스가 아닌 어트리뷰트 ex-type=text), 자식요소 선택자, 후손요소 선택자(밑에 있는 모든 애들), 인접형제 선택자, 모든형제 선택자, 가상클래스 선택자, 가상요소 선택자

- 이런 선택자들이 있으며 css파일이 아닌 js에서 사용하고 싶을때는 querySelector를 사용하여 하나의 앨리먼트를 검색해서 반환할 수 있다.

- 여러개인 경우 첫번째, 못찾은 경우 null, 문법에 맞지 않을때는 익셉션 에러가 발생한다.

- querySelectorAll 을 사용하면 인수로 전달한 css 선택자를 만족시키는 모든 앨리먼트를 찾아 NodeList객체로 반환한다. 얘도 유사 배열 객체이면서 이터러블이다.

- css 선택자를 사용하는 querySelector와 querySelectorAll은 쓰긴 편하지만 성능이 getElementBy\*\* 애들보다 느린 것으로 알려져 있다. get으로 가져올 수 있는 클래스나 아이디일때는 get을 사용하도록 하자.

- 노드.matchs 메서드는 인수로 전달한 css 선택자로 노드를 취득할 수 있는지를 알려준다. 이벤트 위임 쓸 때 유용하다고 한다.

### HTMLCollection과 NodeList객체

공통점 : 유사 배열 객체이면서 이터러블이다. 노드 객체의 상태변화를 실시간으로 반영하는 LIVE = 살아있는 객체이다.

차이점 : HTMLCollection은 언제나 LIVE 객체이고 NodeList는 보통 NON-LIVE 객체로 동작되고 있다가 조건 충족시 LIVE 객체로 동작할 수 있다.

주의점 : 살아있는 객체 = 실시간으로 변화가 반영되기에 반복문 같은거 돌렸을 때 예상치 못한 결과가 발생할 수 있다. 배열로 바꿔 돌리거나 조심하자.

- 스프레드 문법이나 Array.from 메서드를 사용하면 간단하게 배열로 만들 수 있다.

### 노드 탐색

- 특정 노드가 아닌 노드의 위치에 따라 노드를 탐색하고 결과를 반환할 수 있다.
- 읽기 전용, 노드 탐색 프로퍼티는 접근자만 갖고 있다.
- 주의점 : 빈 요소노드를 만들면 공백 텍스트노드가 자동으로 하나 생성되니 탐색시 주의해야 한다.

```js
childNodes : 자식노드를 모두 검색해서 반환, 텍스트노드도 포함되어 반환
children : 자식노드 중에서 요소노드만 검색해서 반환
firstChild : 첫번째 자식노드 반환, 텍스트노드 / 요소노드
lastChild : 마지막 자식노드 반환, 텍스트노드 / 요소노드
firstElementChild : 첫번째 자식 '요소'노드 반환
lastElementChild : 마지막 자식 '요소'노드 반환
hasChildNodes : 자식노드가 존재하면 true 아니면 false
노드.parentNode : 해당 노드의 부모노드 반환
노드.previousSibling : 해당 노드의 이전 형제 노드 반환, 텍스트노드 / 요소노드
노드.nextSibling : 해당 노드의 다음 형제 노드 반환, 텍스트노드 / 요소노드
노드.previousElementSibling : 해당 노드의 이전 형제 '요소'노드 반환
노드.nextElementSibling : 해당 노드의 다음 형제 '요소'노드 반환
```

### 노드의 텍스트 값 조작하기

1. 노드.nodeValue : 텍스트 노드일 경우 이걸 사용해서 참조, 할당하여 값을 바꿀 수 있다. 요소노드일 경우 해당 텍스트 값을 가진 요소노드의 첫번째 자식이 텍스트노드이므로 해당 요소노드 취득 후 firstChild 메서드를 써서 텍스트노드를 추출하자.

2. 노드.textContent : 해당 '요소'노드의 콘텐츠 영역(시작 태그와 종료 태그 사이)에 있는 모든 텍스트를 반환한다. 이 때 HTML 마크업은 무시된다. 요소노드의 textContent 프로퍼티에 문자열을 할당하면 모든 자식노드가 제거되고 할당한 문자열이 텍스트로 추가된다. 이때 할당한 문자열에 HTML마크업이 되어 있었더라도 파싱되지 않고 일반 문자열로 취급된다.

### 노드의 교체, 생성, 삭제 = DOM 조작

- 성능 최적화와 직접적으로 관련이 있으므로 주의해서 쓰자.

#### 교체, 수정

1. 요소노드.innerHTML : 해당 요소노드의 HTML 마크업을 취득하거나 변경한다. 참조사용시 존재하는 HTML 마크업을 문자열로 반환한다. textContent와 달리 재할당시 할당한 문자열에 포함되어 있는 HTML마크업이 파싱되어 자식노드 모양으로 돔에 반영된다.

- 이때 자바스크립트 코드를 할당해서 파싱과정에 코드를 끼워넣는 크로스 사이드 스크립팅 공격이라는 해킹기법이 있다. 다행히 HTML5에서는 innerHTML 프로퍼티로 삽입된 script 요소 내의 자바스크립트 요소를 실행하지 않는다.

- 하지만 조금 우회하면 금방 뚫릴수 있으므로 HTML 새니티제이션 함수/라이브러리 등을 사용해서 잠재적 위협이 있는 애들을 살균해주면 좋다.

- 뭔가 새로 할당했을때 기존에 있는걸 모두 지워버리는데다가 새로운 요소의 삽입 위치를 지정할수 없다는 단점도 있다. 간단한 추가에만 쓰기.

2. 요소노드.insertAdjacentHTML 을 쓰면 기존 요소를 제거하지 않고 4가지 키워드로 위치를 지정하여 요소를 추가할 수도 있다. 그치만 크로스 사이트 스크립팅을 당할 위험도는 비슷하므로 조심

#### 생성

1. createElement : 이걸 쓰면 요소노드를 만들수 있다. 이 메서드로 생성한 요소 노드는 기존 돔에 추가되지 않고 독립적으로 생성된다. 또 휘하의 텍스트노드를 포함한 어떤 자식노드도 갖고있지 않기에 이들을 추가하기 위해서는 추가작업이 필요하다.

- 자식노드 추가하는 법 : appendChild를 쓰거나 textContent를 사용해서 깔끔하게 새로 할당해주자.

- 독립적으로 존재하기 때문에 portal을 사용한 모달 만들기에 좋다.

- 해당 노드를 다른 어떤 노드의 자식으로 추가하여 돔에 연결하는 법 : appendChild를 사용해서 존재하는 요소의 마지막 자식으로 추가해주기. 돔은 이 과정에서만 변경된다. 그래서 여러개 만들때는 그 노드들을 컨테이너 노드에 담아서 appendChild하면 여러가지 요소를 추가하면서도 돔의 변경을 최소화할 수 있다.

- 이 과정에서 생기는 불필요한 컨테이너 노드는 프래그먼트를 사용함으로써 없는 것처럼 해결할 수 있다. 얘는 존재하는 상태이다가 돔에 정식으로 추가되는 순간 자신은 제거되고 자식노드들만 돔에 추가해주는 노드이다.

#### 이동

- 원래 존재하는 애를 appendChild하면 원래 있던 장소에서 사라지고 이동한 곳에 나타나게 된다. 예전에 텔레포트 하는 순간 원본은 죽는거고 재조립된 것은 원본의 기억을 가진 다른 존재일 뿐이다라는... 글을 읽은 적이 있는데 그거랑 비슷한 것 같다.

#### 노드 복사

- 노드.cloneNode() : 인수에 true를 전달하면 깊은 복사, 그냥 보내면 얕은 복사로 안에 있는 텍스트노드가 같이 전달되지 않는다. 사본은 돔과 연결되어 있지 않기에 연결 작업이 필요하다.

#### 노드 교체/삭제

- 할당을 이용한 교체도 가능하지만 replaceChild(newNode, oldNode)로 해당 노드의 자식노드들을 교체할 수 있다. oldNode는 반드시 이미 존재하는 노드의 자식노드여야 한다. newNode가 추가된 후 oldNode는 제거된다.

- removeChild(child) 하면 해당 노드의 자식노드를 제거할 수 있다.

### 어트리뷰트 노드

- HTML 요소는 여러개의 어트리뷰트를 가질 수 있다.
- HTML 어트리뷰트 : HTML 요소의 동작을 제어하기 위한 추가적인 정보를 제공하는 어트리뷰트로 HTML요소의 시작태그 안에 어트리뷰트 이름 ="어트리뷰트 값" 형식으로 정의한다.

```JS
<input id="1" type="checkbox"></input>
```

- JSX에서는 Props를 이 형태로 전달한다.
- 모든 HTML요소에서 공통적으로 사용할 수 있는 것은 글로벌 어트리뷰트(아이디, 클래스, 스타일 등)와 이벤트핸들러 어트리뷰트(온클릭 온로드 온서밋 온포커스 등)이다.
- 인풋과 같은 특정 HTML 요소에만 사용할 수 있는 어트리뷰트도 있다.
- HTML 어트리뷰트의 역할은 HTML요소의 초기상태를 지정하는 것이다. 이 값은 변하지 않는다. 변하는 것은 파싱 후의 돔 프로퍼티이다.

- 돔 프로퍼티는 살아있는=LIVE 객체라서 최신상태를 관리할 수 있다.
- 사용자 입력에 의한 상태변화와 관계가 없는 경우에는 어트리뷰트는 언제나 돔 프로퍼티와 동일한 값으로 연동된다.

- data 어트리뷰트와 dataset 프로퍼티 : data- 뒤에 임의의 이름을 붙이면 data 어트리뷰트가 되어서 사용자 정의 어트리뷰트와 자바스크립트 간에 데이터를 교환할 수 있다. data 어트리뷰트의 값을 엘리먼트.dataset 프로퍼티로 취득할 수 있는데 이때 dataset 프로퍼티는 해당 요소의 모든 data 어트리뷰트의 정보를 제공하는 DOMStringMap 객체를 반환한다.

- DOMStringMap 객체는 해당 커스텀 어트리뷰트의 이름을 카멜케이스로 변환한 프로퍼티를 가지고 있는데 이걸로 값을 취득하거나 재할당하여 변경할 수 있다.

- dataset으로 존재하지 않는 프로퍼티를 할당할 경우 HTML 요소에 해당 이름을 케밥케이스로 변환한 data 어트리뷰트가 자동으로 추가된다.

#### 클래스 어트리뷰트

- 클래스는 공백으로 구분하여 여러개를 가질 수 있다.
- className 프로퍼티로 추가할 수 있지만 한개씩이라 불편하다.
- classList 프로퍼티를 사용하면 class 어트리뷰트의 정보를 담은 DOMTokenList 객체를 반환한다. 이 객체는 여러가지 유용한 메서드를 제공한다.

```js
a.classList.add("apple", "banana");
// 하나하나 추가할 수 있음
a.classList.remove("apple", "banana");
// 하나하나 삭제할 수 있음, 이미 삭제되었다면 에러가 나지 않고 무시된다.
a.classList.item(1);
// 해당 번째 인덱스를 반환
a.classList.contains("apple");
// 있으면 true
a.classList.toggle("apple");
// 일치하는게 존재하면 제거, 없으면 생성
// 두번째 인수로 조건식(불리언)을 전달하여 이 조건식이 true일때 추가 false일때 제거 할수 있다.
```

### 스타일 어트리뷰트

- getComputedStyle을 사용하면 인라인, 링크, 임베딩, 상속, 기본등의 모든 스타일을 다 합쳐서 최종적으로 뭐뭐가 적용되어 있는지를 CSSStyleDeclaration 객체에 담아 반환해준다. 두번째 인수로 가상선택자(의사요소)를 지정하여 해당 스타일을 반환받을 수 있다.

### 떠오르는 생각이 있었나요? 나의 사색을 기록해 봅시다 💭

```
참 길었다. dom트리의 세계도 참 넓구나 생각이 든다.
css 할때 도움될 것 같은 정보가 참 많았다.
특히 요소 선택 + 의사요소를 사용하는 편리한 방법들과,
마지막꺼... 한참 작업하다가 조그만 박스 하나가 삐져나와있을때... 아무리해도 안들어갈때...!
그때 평가된 스타일=computedStyle을 목록으로 뽑아서 확인하면 무척 편리할 것 같다.
```
