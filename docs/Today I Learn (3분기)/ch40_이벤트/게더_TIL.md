## 📕 오늘 공부한 내용, 이렇게 정리해 봅시다. ✒

**TIL(Today I learn) 기록일** : 2022.09.13

**오늘 읽은 범위** : 40장 이벤트

### 이벤트 드리븐 프로그래밍 📑

- 프로그래밍의 구분은 대개 제어권을 어디에 두느냐인데, 이벤트 드리븐 프로그래밍은 인터랙션(상호작용)에 제어권을 맡기는 프로그래밍이다.

- 지금까지 배운 함수형 프로그래밍, 선언적 프로그래밍이 개발자-개발자, 개발자-애플리케이션이라면 이벤트 드리븐은 사용자-애플리케이션이다. 사용자의 행동을 전제로 하여 프로그램을 짠다.

- 개발자는 명시적으로 함수를 호출하는 것이 아니라 이벤트 핸들러를 사용해서 브라우저에게 함수 호출을 위임한다.

---

### 단어장 📑

- 이벤트 : 브라우저가 사용자의 행동, 또는 행동으로 인하여 발생된 일련의 과정을 감지하여 발생시킬 수 있는 트리거들. 사용자와 브라우저간 상호작용으로 인한 결과.

- 이벤트 타입 : 이벤트의 종류를 나타내는 문자열, 약 200여가지가 있으며 사용빈도가 높은 이벤트는 알아두는 것이 좋다. 마우스, 키보드, 포커스, 폼, 값 변경, 스크롤, 로딩 완료 등등 여러가지가 있다.

- 이벤트 핸들러 : 이벤트가 발생했을 때 브라우저에 호출을 위임하게 한 함수. 이 함수만으로는 사용이 안되고 브라우저에게 `이벤트 핸들러의 호출을 위임하는 과정`이 필요하다.

- 이벤트 핸들러 등록 : 브라우저에게 이벤트 핸들러의 호출을 위임하는 과정, 3가지 방법이 있다.

### 이벤트 핸들러 등록하기 📑

1. 이벤트 핸들러 어트리뷰트 사용

- HTML 요소의 어트리뷰트에는 이벤트 핸들러 어트리뷰트가 있다. 이벤트타입 문자열을 어트리뷰트 키로 하고 어트리뷰트 값으로 함수 호출문등의 문(statement)을 할당하면 핸들러가 등록된다.

- 주의할 것은 형식으로 함수참조는 안받아주고 반드시 인수를 담을 수 있는 문 형태여야 한다는 것이다. 왜냐하면 이 값이 암묵적으로 생성되는 이벤트 핸들러 함수의 함수 몸체가 되기 때문이다. 문 형태이기만 하다면 여러개의 문을 한번에 보내도 상관없다.

- 리액트에서 거의 밥먹듯이 쓴다! 버튼이 아닌 div에도 왠만한 모든 앨리먼트에는 온클릭이 달려있다. 하지만 form 관련 어트리뷰트나 input 관련 어트리뷰트 등 특수한 앨리먼트에만 사용가능한 애들이 따로 있다.

2. 이벤트 핸들러 프로퍼티 사용

- 어트리뷰트 노드가 아니더라도 노드 객체는 이벤트에 대응할 수 있는 이벤트 핸들러 프로퍼티를 가지고 있다. 메서드 쓰듯이 키를 타고 가서 함수를 바인딩하면 사용할 수 있다.

- 사용 방법 : 타깃을 셀렉터 등을 사용해서 지정 -> 발생할 이벤트 타입을 .쓰고 입력 -> 이벤트 핸들러 함수를 연결해준다.

- 이때 정확히 그 타겟에 지정해도 되지만 전파된 이벤트를 캐치할 수 있는 DOM 노드 객체에 바인딩해도 된다.

```js
function handleClick() {
  console.log("handleClick");
}

const $btn = document.querySelector("button");

$btn.onclick = handleClick;
```

- 이렇게 하면 HTML에서 자바스크립트 함수를 깔끔하게 분리할 수 있다는 장점이 있다. 단점은 바인딩 시 대상지정이 귀찮고 한개 프로퍼티에 하나의 이벤트 핸들러만 바인딩할수 있다는 것이다. 전파와 캡쳐를 적극적으로 이용해야 한다.

- 이벤트 핸들러 제거시에는 null을 해당 핸들러에 재할당해주면 된다.

3. addEventListener 메서드 사용

- DOM은 현재 레벨 4까지 진화했는데 레벨 2에서 EventTarget.prototype.addEventListener 메서드를 사용하는 방식이 도입되었다. 2번과 비슷한 방식을 쓰지만 2번과 달리 여러개의 이벤트 핸들러를 등록할 수 있어서 좋다.

```js
function handleClick() {
  console.log("handleClick");
}

const $btn = document.querySelector("button");

$btn.addEventListener("click", handleClick);
$btn.addEventListener("blur", handleClick);
```

- 여기서 여러개를 등록할 수 있다는건 온클릭, 온포커스를 따로따로 등록할 수 있다는 뜻이다. 온클릭 2개는 안된다. 아 그치만 이때 2번과 3번은 감시 방식이 다르기 때문에 두 방법을 같이 쓰면 둘 다 호출할 수 있다.

- 등록시 버블링이나 캡처링 여부를 지정할 수 있어서 좋다.

- 애드 이벤트리스너는 한번 등록되면 계속 애플리케이션에서 돌아가기 때문에 점점 과부하가 걸리게 된다. 만들때는 꼭 리무브리스너도 같이 써주어야 한다. 리액트에서는 useEffect의 클린 기능을 쓰기도 하고 여러 위치에서 여러 방법으로 사용할 수 있다.

- 이때 애드와 리무브에 전달한 인수가 일치하지 않으면 핸들러는 제거되지 않는다. 여기서 말하는 인수에는 핸들러함수 이름도 포함되기에 addEventListener를 쓸때는 무명함수를 쓰지 않도록 하자.

### 이벤트 객체 📑

- 이벤트가 발생하면 이벤트에 관련한 다양한 정보를 담고 있는 이벤트객체가 생성되며 생성된 이벤트 객체는 이벤트 핸들러의 첫번째 인수로 전달된다.

- addEventListener나 프로퍼티로 생성한 애는 아무거나, 이벤트 핸들러 어트리뷰트로 생성한 애는 event라는 이름으로 전달되므로 왠만하면 이벤트 핸들러 함수를 제작할때는 인수에 event를 써주자.

- 공통 프로퍼티 : 이벤트 객체의 인터페이스 = 프로토타입에 정의되어 있는 이벤트 관련 프로퍼티를 알아두면 좋다.
  | 공통 프로퍼티 | 설명 | 타입 |
  | --- | --- | --- |
  | type | 이벤트 타입| string |
  | target | 이벤트를 발생시킨 DOM 요소 | DOM 앨리먼트 노드 |
  | currentTarget | 이벤트 핸들러가 바인딩된 DOM 요소 | DOM 앨리먼트 노드 |
  | eventPhase | 이벤트 전파 단계 0, 1: 캡처링, 2: 타깃, 3:버블링 | number |
  | timeStamp | 이벤트가 발생한 시각 | number |
  | isTrusted | 메서드가 아닌 사용자의 행위에 의해 발생한 이벤트인지 여부 | boolean |

- 공통 프로퍼티 말고 이벤트에 따라 각각 특별한 프로퍼티를 가지고 있다. 예를 들어 체크박스는 checked 프로퍼티를 가지고 있어서 이걸로 체크여부를 알수 있고, 마우스관련 이벤트 객체들은 마우스 포인터의 좌표 정보를 나타내는 pageX, pageY 등의 프로퍼티를 가지고 있다.

- 인풋에 한글을 입력하고 엔터를 누르면 keyup이 두번 호출되는 현상이 발생한다. keydown이벤트를 사용하자.

### 이벤트 전파 📑

- 돔 트리 상에 존재하는 돔 앨리먼트 노드에서 발생하는 이벤트는 이벤트 객체를 생성하며 이는 돔트리를 통해 전파된다. 전파되지 않는 종류를 제외하고는 일반적으로 전파된다.

- 전파 순서는 캡처링(하위로) -> 타겟 -> 버블링(다시 상위) 이며 일반적으로 타겟과 버블링만 캐치하고 캡처링 단계는 캐치되지 않지만 addEventListener의 3번째 인수에 true를 전달하면 셋 다 캐치한다.

- addEventListener에서 target, currentTarget, eventPhase 등으로 낚을 물고기를 확인하고 적절한 이벤트를 부여할 수 있다.

- 예를 들어 ul에 이벤트 핸들러를 바인딩하고 ul의 하위요소인 li를 클릭하여 이벤트를 발생시킨다면 타겟은 li이고 커런트타겟은 ul이다. 이벤트를 캐치하기 위해 하위 컴포넌트에 갈 필요가 없다는 뜻이다.

- 이벤트 전파를 잘 이용해서 달력같은걸 만들거나 하면 좋다.

### 이벤트 위임 📑

- 이벤트 위임은 이벤트 전파를 잘 이용하는 방법 중 하나이다. 상위 DOM 요소에 이벤트 핸들러를 등록하면 하위 DOM 요소의 갯수나 이벤트 핸들러 여부에 신경쓰지 않아도 된다.

- 이벤트 위임을 사용할 때 주의점은 트리거되는 DOM요소가 개발자가 기대한 DOM 요소가 아닐 수도 있다는 점이다. 원하는 DOM 요소에 한정하여 이벤트 핸들러가 실행될 수 있도록 코드를 테스트하고 이벤트 타겟을 .matches 메서드 같은 걸로 검사해 줄 필요가 있다. 타겟과 커런트타겟의 차이점에도 주의하자.

### 이벤트 방지 📑

- preventDefault : 돔 요소의 기본 동작을 무효화 시킨다. 이때 기본 동작에는, a를 클릭했을때 해당 링크로 이동이라던지, form을 submit했을 때 새로고침이 된다던지, checkbox를 클릭했을때 체크 표시가 된다던지 하는 것들이 있다.

- stopPropagation : 이벤트 전파 방지. 하위 돔요소가 자기 이벤트를 개별적으로 처리하고 자신에게 바인딩된 이벤트 핸들러만 실행되도록 하고 싶을때 쓴다.

- 얘는 이벤트 전파가 무효화되는 데드존을 만들어버리기 때문에 되도록 쓰지 않는게 좋다는 칼럼을 읽은 적이 있다.

### 이벤트 핸들러 내부의 this 📑

1. 일반 함수의 내부에서 this 사용 : window(일반 함수로서 호출되는 함수 내부의 this는 전역 객체를 가리키기에)
2. 이벤트 핸들러에 인수로 전달된 this : 이벤트를 바인딩한 DOM 요소(currentTarget)
3. addEventListener/프로퍼티 : 이벤트를 바인딩한 DOM 요소(currentTarget). 단 이때 화살표함수로 핸들러를 제작했다면 화살표함수는 자체의 this를 갖지 않기에 상위 스코프의 this를 가리키게 된다.
4. 클래스에서 이벤트핸들러를 바인딩하는 경우 : 명시적으로 bind메서드를 써서 this를 전달하지 않으면 클래스가 생성할 인스턴스가 아닌, 인수로 전달된 커런트타겟을 가진 애들만 만들어내게 되니 조심! 화살표함수를 쓰는 것도 방법이다.

### 알면 좋은 것 📑

- 이벤트객체 또한 객체여서 생성자함수로 커스텀 이벤트를 생성할 수 있다. 다만 이 경우 정말 1부터... 버블링, 캡처링 여부까지도 커스텀 해주어야 하고 isTrusted 프로퍼티의 값이 항상 false로 남는다는 단점이 있다.

### 떠오르는 생각이 있었나요? 나의 사색을 기록해 봅시다 💭

```
프론트엔드여서 좋은 점은 역시 이벤트를 제어하는게 아닐까...
이벤트에 따라 애니메이션 효과를 넣어주면 자잘하게 기분이 좋다.
```
