## 📕 오늘 공부한 내용, 이렇게 정리해 봅시다. ✒

**TIL(Today I learn) 기록일** : 2022.09.18

**오늘 읽은 범위** : 45장 프로미스

### 자바스크립트의 비동기 처리 패턴 📑

- 자바스크립트는 동기인데 비동기처럼 동작하기 위해 여러 방법을 사용한다. 전통적으로 콜백 패턴을 사용해왔었고, 현재는 promise와 async/await 패턴을 사용하는 것이 대세로 굳어져 있다.

- 면접에서 콜백패턴은 콜백지옥을 불러와서 안된다고 대답하자, 콜백지옥이 정확히 뭔지 아냐는 팔로업이 들어온적이 있다. promise가 포함된 es6의 출시는 2015년이며 async/await가 포함된 es8의 출시가 2017년으로 내가 코딩을 접할 즈음에는 콜백패턴이란건 권장하지 않음/한계가 있음 정도로만 표현되는 과거의 흐름이었다.

- 그래서 콜백지옥=쓰면안됨 정도만 생각하고 정작 그게 정확히 뭔지는 모른채로 편안하게 프로미스 객체를 사용하고 있었다! 그치만 면접에서 보는 면접관님들은 5~10년차 혹은 그이상의 경력을 갖고계신 분들이라는 것을 생각해보면 이런 개념을 알아두는게 기술면접에 무척 도움이 될것 같긴 하다.

---

### 콜백 패턴 📑

- 콜백패턴 : 자바스크립트에서의 비동기 처리를 위한 패턴. 콜백함수를 사용해서 비동기처리를 한다.

### 콜백패턴의 단점 📑

#### 1. 콜백지옥

- 비동기 함수 내부의 비동기로 동작하는 코드는 비동기 함수가 종료된 이후에 완료된다. 그렇기에 비동기 함수 내부의 비동기코드=콜백함수에서 처리결과를 외부로 반환하거나 상위 스코프의 변수에 할당하면 기대한 동작이 안나온다.

- 왜냐하면 비동기코드는 태스크큐에 쌓이고 응답이 올때까지 나머지 코드들을 착착 처리해버리기 때문...!

- 그래서 비동기 함수의 처리 결과=서버응답에 대한 후속처리를 하나의 비동기 함수 내부에서 다 수행시켜야 하는데, 이때 이 수행 코드도 콜백함수(비동기함수)로 해야 범용성이 떨어지지 않는다.

- 그래서 콜백함수 -> 의 안에 들어있는 비동기 처리결과에 대한 후속처리를 수행하는 콜백함수 -> 의 비동기 처리결과에 대한 후속처리를 수행하는 콜백함수의 느낌으로 catch문 같은게 무한하게 안쪽으로 증식해나가는 것을 콜백지옥이라고 한다.

- 콜백지옥은 1. 가독성을 망치고, 2. 에러이벤트는 호출자 방향으로 전파되기에 비동기함수의 후속처리용 콜백함수가 발생시킨 에러는 블록이 잡아내질 못한다. 3. 여러 개의 비동기를 처리할 경우 지옥이 증식하면서 실수가능성이 높아진다.

### 프로미스 패턴 📑

- 프로미스 생성자 함수를 new 연산자와 함께 호출하면 프로미스 객체를 생성한다. 호스트 객체가 아닌 표준 빌트인 객체이다. 프로미스 생성자 함수는 엑스큐터 함수(비동기 처리를 수행하기 위한 전용 콜백 함수)를 전달받아서 비동기 처리를 수행하고, 결과값을 리턴한다.

- 엑스큐터 함수 : (resolve, reject) 이 두가지를 인수로 가지는 특별한 콜백함수이다. 리졸브는 성공이고 리젝트는 실패다. 이 두개의 인수를 엑스큐터에 전달하면 액스큐터 함수 내부에서 비동기처리를 수행 후, 성공이면 리졸브를 반환하고 실패하면 에러를 리젝트에 담아 반환해준다.

#### 프로미스 객체가 관리하는 것 📑

1. 프로미스 객체의 진행 상태

- settled(fulfilled, rejected) 완료된 상태와, pending 수행중인 상태 두개로 나뉜다. 일단 settled가 되면(성공이든 실패든) 더는 다른 상태로 변화하지 않는다.

2. 프로미스 객체의 비동기 처리 결과 값(데이터 or 에러)

- 프로미스는 처리결과를 즉시 반환하지 않고 프로미스 객체 안에다가 진행상태와 같이 가지고 있다. 얘를 떼어오려면 후속처리메서드를 사용해야 한다.

### 프로미스의 후속 처리 메서드 📑

- 프로미스에는 후속메서드가 3개 있다. 프로미스의 비동기 처리 상태가 변화하면 그 변화에 따라 후속메서드에 인수로 전달한 콜백함수가 선택적으로 호출된다. 이때 프로미스의 처리 결과값이 인수로 같이 전달된다.

- 모든 후속메서드는 프로미스를 반환하며, 비동기이다.

1. then

- 가장 많이 쓸거 같은 메서드. 언제나 프로미스를 반환하며, 콜백함수 2개를 선택적으로 전달받기에 성공과 실패를 둘다 처리할 수 있다.

- 첫번째 함수=인수는 프로미스가 fulfilled 상태가 되면 호출되고, 결과값을 인수로 가진다. 두번째 함수=인수는 rejected 상태가 되면 호출되고, 프로미스의 에러를 인수로 가진다.

- 프로미스가 끝나면 같이 닫히므로 미리 데이터를 복사해서 꺼내주자.

2. catch

- 캐치는 한개의 콜백함수만을 전달받는다. 리젝트 상태일때 오는 실패함수이다. 동작방식은 then과 같다. then만으로 두가지 다 처리 가능한데 굳이 이걸 쓰는 이유는...

- 가독성 : 함수를 따로 빼면 가독성이 상승한다.
- 에러 캐치 : then의 2번째 콜백함수로 에러를 받으면, 1번째 콜백함수 내부의 에러를 못잡는다. 2번째에 도달하는건 이미 상태가 rejected로 고정된 다음일때 뿐이기 때문이다. 그치만 캐치를 사용하면 then의 1번째 콜백함수에서 발생하는 에러도 캐치할 수 있다.

3. finally

- 성공이나 실패와 상관없이 프로미스 상태의 변화시 무조건 한번 호출된다. 결과와 상관없이 공통적으로 수행해야 할 처리 내용이 있을 때 유용하다.

### 프로미스 체이닝 📑

- 말이 어렵지만 then을 여러개 쓰는거다. 프로미스를 여러개 쓰려고 할때 어떻게 해야하는가... 라는 질문을 받았던 첫 면접이 생각난다. 프로미스는 프로미스 객체 내부에서 여러가지 결과값+상태값을 관리하기에 콜백 헬이 발생하진 않지만 여전히 콜백패턴을 사용하고 있기 때문에 이렇게 타고 타고 가야 한다.

- 프로미스의 후속처리 메서드들은 언제나 프로미스를 반환하게 되어 있으므로 프로미스의 결과값(후속메서드의 반환값)에 대해서 후속메서드를 사용할 수 있다. 이 결과값또한 프로미스로 나오기 때문에 프로미스 안에 프로미스 안에 프로미스가 들어간다. 이를 체이닝이라고 한다.

### 프로미스의 정적 메서드 📑

1. resolve/reject : 성공과 실패값을 담은 프로미스를 각각 생성한다.

2. Promise.all : 프로미스 여러개를 병렬처리할때 사용한다. 각각 독립적으로 시행되게...! 이 메서드는 배열을 인수로 전달받으며, 배열의 모든 프로미스가 fulfilled 상태가 되면 그걸 모아 새로운 배열을 반환하며 종료된다.

- 배열이기 때문에 처리 순서도 보장된다.
- 단, 하나라도 rejected 상태가 되면 함수가 그자리에서 즉시 종료된다...

2. Promise.allSettled : all과 같은 방식으로 작동하지만 all과 달리 모든 배열 안에 든 프로미스가 settled 상태가 되면 처리 결과를 다시 배열로 반환해주는 애다. es11에 도입된 애로 대부분의 모던 브라우저에서 지원하는 기능이다.

### 마이크로 태스크 큐 📑

- 프로미스의 후속처리 메서드의 콜백함수는 마이크로태스크 큐에 들어가서 우선순위가 일반 큐보다 높다.

- Microtask Queue(프로미스 등 비동기호출) -> Animation Frames(브라우저 렌더링 관련 태스크) -> (일반 태스크큐)Task Queue
