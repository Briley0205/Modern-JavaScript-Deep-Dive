# 📕 오늘 공부한 내용, 이렇게 정리해 봅시다.

**TIL(Today I learn) 기록일** : <br>
2022.09.18

**오늘 읽은 범위** : <br>
45장

<br>

## ✨**45장, 프로미스**✨

프로미스는 전통적인 콜백 패턴이 가진 단점을 보완하며 비동기 처리 시점을 명확하게 표현할 수 있다는 장점이 있다.

### ➡️콜백 헬

콜백 함수를 통해 비동기 처리 결과에 대한 후속 처리를 수행하는 비동기 함수가 비동기 처리 결과를 가지고 또다시 비동기 함수를 호출해야 한다면 콜백 함수 호출이 중첩되어 복잡도가 높아지는 현상이 발생한다. 이를 `콜백 헬`이라 한다.

<br>

### ➡️프로미스의 생성

프로미스 생성자 함수는 비동기 처리를 수행할 콜백 함수를 인수로 전달받는데 이 콜백 함수는 resolve와 reject 함수를 인수로 전달받는다.

프로미스는 아래처럼 비동기 처리가 어떻게 진행되고 있는 지를 나타내는 상태 정보를 갖는다.
|프로미스의 상태 정보 | 의미 | 상태 변경 조건|
|:----:|:----:|:----:|
|pending|비동기 처리가 아직 수행되지 않은 상태|프로미스가 생성된 직후 기본 상태|
|fulfilled|비동기 처리가 수행된 상태(성공)|resolve 함수 호출|
|rejected|비동기 처리가 수행된 사태(실패)|reject 함수 호출|
<br>

- 비동기 처리 성공:<br>
  resolve 함수를 호출해 프로미스를 fulfilled 상태로 변경한다.

- 비동기 처리 실패:<br>
  reject 함수를 호출해 rejected 상태로 변경한다.

<br>

### ➡️프로미스의 후속 처리 메서드

프로미스의 비동기 처리 상태가 변화하면 후속 처리 메서드에 인수로 전달한 콜백 함수가 선택적으로 호출된다. 후속 처리 메서드는 아래와 같다.

- Promise.prototype.then<br>
- Promise.prototype.catch<br>
- Promise.prototype.finally<br>

<br>

### ➡️프로미스 정적 메서드

- Promise.resolve / Promise.reject<br>
  이미 존재하는 값을 래핑하여 프로미스를 생성하기 위해 사용

- Promise.all<br>
  여러 개 비동기 처리를 모두 병렬처리할 때 사용

- Promise.race<br>
  Promise.all 메서드와 동일하게 프로미스를 요소로 갖는 배열 등 이터러블을 인수로 전달 받는다. 가장 먼저 fulfilled 상태가 된 프로미스의 처리 결과를 resolve하는 새로운 프로미스를 반환한다.

- Promise.allSettled<br>
  전달받은 프로미스가 모두 settled 상태가 되면 처리 결과를 배열로 변환한다.

<br>

### ➡️fetch

fetch 함수는 XMLHttpRequest 객체와 마찬가지로 HTTP 요청 전송 기능을 제공하는 클라이언트 사이드 Web API다. 비동기 처리를 위한 콜백 패턴의 단점에서 자유롭다. fetch 함수는 비교적 최근에 추가된 Web API로서 인터넷 익스플로러르 제외한 대부분 모던 브라우저에서 제공한다.
