## 📕 오늘 공부한 내용, 이렇게 정리해 봅시다. ✒

**TIL(Today I learn) 기록일** : 2022.09.17

**오늘 읽은 범위** : 46장 제너레이터와 async / await

### 제너레이터 📑

- ES6에서 나온 제너레이터 함수. es6에서 프로미스가 출시되고 es8에서 async가 나오기까지의 간극을 메워주는, 비동기처리를 위한 함수이다.
- 코드 블록의 실행을 일시 중지했다가 필요한 시점에 재개할 수 있는 특수 함수다.

- function에 \*아스타를 달고 yield 표현식이 들어가면 제너레이터 함수다.
- 화살표 함수로는 제너레이터 함수를 만들 수 없다.
- 생성자함수로 호출할 수도 없다.

- 함수 호출자에게 함수 실행의 제어권을 양도하며, 함수 호출자에게 함수의 상태를 알릴수 있다. 반대도 가능. 실행시 프로미스처럼 제너레이터 객체를 반환한다.

---

### 제너레이터 객체 📑

- 이터러블이면서 동시에 이터레이터이다. yield키워드와 next메서드로 실행을 일시중지했다가 필요한 시점에 다시 재개할 수 있다.

- 일반 함수는 호출 이후 제어권을 함수가 갖지만 제너레이터는 호출자에게 다시 yield로 앙도해주는 형태여서 그렇다.

### 사용처 📑

- 무한 이터러블을 만들 때 편리하다.
- 후속메서드(then 같은거) 없이 비동기처리를 동기처리처럼 작동하도록 구현할 수 있다. 관련 라이브러리도 있다.

### async / await 의 등장 📑

- 제너레이터의 동기처리처럼 작동하는 편리함을 가져가지만 코드가 장황하지 않게, 내부적으로 처리하도록 구현할 수 있는 async/await가 es8에서 도입되었다.

- async를 함수에 붙이면 걔는 async함수가 되고 async 함수는 언제나 프로미스를 반환한다. 그리고 await 키워드는 반환받고 싶은 프로미스(처리결과) 앞에 쓰면 되는데 async 함수 내에서만 사용할 수 있는 특수한 키워드이다.

- await이 하는 역할은 간단하다. 어떤 함수 내부에서 await 뒤에 적힌 프로미스가 있으면, 걔가 settled 상태가 될때까지 대기했다가 그 결과를 await에 할당해서 돌려준다.

- 그래서 await을 한 함수에 너무 많이 쓰면 안좋다. await은 다른 애들과는 비동기처리이지만 같은 await끼리는 동기처리이기 때문... promise.all 같은걸로 병렬처리 해주자. 그치만 await끼리의 순서가 보장된다는 것은 엄청난 장점이다. 알고 있다면 어딘가에 쓸데가 있겠다.

### async / await 에러 처리 📑

- 에러가 발생하면 발생한대로 결과가 들어오기 때문에 후속메서드 catch를 사용해서 에러를 잡을 수 있다. 그치만 코드 통일을 위해서 try/catch 문을 같이 사용해주면 가독성도 좋고 편하다.

### 단어장 (모르는 용어가 있었다면, 간단히 정리해 봅시다) 🔖

- 제너레이터: 코드 블록의 실행을 일시 중지했다가 필요한 시점에 재개할 수
  있는 특수한 함수. 이터러블한 숫자를 무한대로 생성해주는 애라고 생각했다...
