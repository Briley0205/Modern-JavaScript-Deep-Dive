　## 📕 오늘 공부한 내용, 이렇게 정리해 봅시다. ✒

**TIL(Today I learn) 기록일** : 2022.09.20

**오늘 읽은 범위** : 47장 에러 처리

### 에러 처리의 필요성 ? 

+ 에러가 발생하지 않는 코드를 작성하는 것은 불가능 하기 때문에, 에러를 처리해야한다. 에러를 그냥 두고 있으면 프로그램은 강제 종료되기 때문 !
+ try...catch문을 사용해서 대응할 수 있다.
```js
try{
  koo();
} catch (err){
  console.error('에러발생', err); 
}
```
+ 이렇게 적절하게 대응하면 프로그램은 강제로 종료되지 않음.

### try...catch...finally
+ error handling이라고도 함
```js
try{
//실행할 코드 , 에러 발생할 가능성이 있는 코드
} catch(err) {
//에러가 발생하면 catch가 실행됨
} finally {
//에러발생과 상관없이 반드시 한번 실행시킴
}
```

### Error 객체
+ Error생성자 함수에는 에러를 상세히 설명하는 에러 메세지를 인수로 전달 할 수있다.
+ const error = new Error('Error입니다.');
+ 에러 생성자 함수는 Error, SyntaxError, ReferenceError, TypeError, 등등이 있고, 이 에러 객체의 프로토타입은 모두 Error.prototype를 상속받는다.

### throw문
+ 에러객체를 생성한다고 에러가 발생안하는 것은 아니다.
+ throw 문의 표현식은 어떤 값이라도 상관없지만, 일반적으로 에러 객체를 지정함! throw뜻대로 에러를 던진다는 것!
+ 에러를 던지면 catch문의 에러 변수가 생성되고 던져진 에러 객체가 할당되며, 그다음 catch의 코드 블록이 실행되는 순이다.

### 에러의 전파
+ 에러는 호출자 방향으로 전파됨
+ throw된 에러를 catch하지 않으면 호출자 방향으로 전파되며, 이때 throw된 에러를 catch하여 적절히 대응하면 프로그램을 강제 종료시키지 않고 코드의 실행 흐름을 복구 할 수 있다.
+ setTimeout이나 프로미스 후속 처리 메서드의 콜백 함수는 호출자가 없으니 주의하자 !!

