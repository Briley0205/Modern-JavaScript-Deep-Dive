## 📕 오늘 공부한 내용, 이렇게 정리해 봅시다. ✒

**TIL(Today I learn) 기록일** : 2022.08.11

**오늘 읽은 범위** : 19장 프로토타입

### 오버라이딩과 프로퍼티 섀도잉

+ 오버라이딩 : 상위 클래스가 가지고 있는 메서드를 하위클래스가 '재정의' 하여 사용하는 방식
+ 오버로딩 : 함수이름이 동일하지만, 매개변수의 타입 or 개수가 다른 메서드를 구현하고 매개변수에 의해 메서드를 구별하여 호출하는 방식 (JS는 지원하지 않지만, arguments 객체를 사용하여 구현가능)
+ 섀도잉 : 상속관계에 의해 프로퍼티가 가려지는 현상

### 프로토타입의 교체

+ 임의로 교체가능. 부모객체인 프로토타입을 동적으로 변경 가능.
+ 프로토타입은 생성자 함수 또는 인스턴스에 의해 교체 가능.

19.9.1 생성자 함수에 의한 프로토타입의 교체
+ 생성자 함수가 생성할 객체의 프로토타입을 객체리터럴로 교체하면, 교체한 객체리터럴에는 constructor 프로퍼티가 없음. (파괴)
+ 그래서 교체한 객체 리터럴에 constructor프로퍼티를 추가하여 프로토타입의 constructor 프로퍼티를 되살림.

### instanceof 연산자

+ 이항연산자로서 좌변에 객체를 가리키는 식별자, 우변에 생성자 함수를 가리키는 식별자를 피연산자로 받습니다. (피연산자가 아닌경우 타입에러)
+ 우변의 생성자 함수의 프로토타입에 바인딩된 객체가, 좌변의 객체의 프로토타입 체인상에 존재하면 true, 없으면 false로 평가됨.
+ constructor프로퍼티와 생성자 함수간의 연결이 파괴되어도 생성자 함수의 프로퍼타입 프로퍼티와 프로토타입간의 연결은 파괴되지 않으므로 instanceof는 아무런 영향을 받지 않음.
+ 즉 constructor를 바꾸는 것은 의미가 없음.. 아마도..? (조금 더 공부!)

### 직접 상속

+ 프로토타입을 지정해서 프로토타입을 상속한 객체 생성
+ 첫번째 매개변수 : 프로토 타입
+ 두번째 매개변수 : 생성할 객체의 프로퍼티키와 디스크립터 객체 전달 (두번째 인수는 옵션이므로 생략 가능!)
+ 프로퍼티 정의가 번거롭다..

### 정적 프로퍼티/ 메서드

+ 생성자 함수로 인스턴스를 생성하지 않아도 참조/호출할 수 있는 프로퍼티/메서드를 말함!

### 프로퍼티 존재 확인

+ in 연산자 : 객체 내에 특정 프로퍼티가 존재하는지 여부 확인
```js
//사용 방법
const person = {
  name: 'koo',
  address: 'seoul'
};
console.log('name' in person); // true , person객체에 name프로퍼티가 존재.
```
+ ES6에는 Reflect.has 메서드 사용 가능! in연산자와 동일하게 동작함.(알아두자)
+ Object.prototype.hasOwnProperty 메서드를 사용해도 객체에 특정 프로퍼티가 존재하는지 확인가능 !

### 프로퍼티 열거

+ for...in 문을 사용해야됩니다.
```js
for(const key in person){
  console.log(key + ': ' person[key]);
};
```
+ for..in문은 객체의 프로토타입 체인 상에 존재하는 모든 프로토타입의 프로퍼티 중에서 프로퍼티 어트리뷰트의 값이 true인 프로퍼티를 순회하며 열거합니다.


---

### 다른 분이 작성하신 TIL에 대한 소감
다른분들은 정리를 깔끔하게 잘 하시네요.. 몇번은 더 읽어봐야할 것 같습니다. 어려운 파트였습니다 개인적으로,,ㅎㅎ
