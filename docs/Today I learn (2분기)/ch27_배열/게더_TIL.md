## 📕 오늘 공부한 내용, 이렇게 정리해 봅시다. ✒

**TIL(Today I learn) 기록일** : 2022.08.26 - 28

**오늘 읽은 범위** : 27장 배열

### 배열이란 📑

- 배열 array는 여러개의 값을 순차적으로 나열한 자료구조이다. 배열은 사용빈도가 매우 높으며 자바스크립트에서는 배열 전용 메서드도 여러개 제공한다. 배열 메서드를 능숙하게 다루면 코딩에 매우 도움이 된다.

- 요소(element) : 배열은 대괄호 안 각 요소들로 구성되는데 이때 요소는 자바스크립트에 존재하는 어떤 형태의 값이라도 될 수 있다.

- 인덱스 : 배열 내의 모든 값은 배열 내에서 자신의 위치를 나타내는 0 이상의 정수인 인덱스 값을 갖는다. 대괄호 표기법으로 각 요소에 접근할 수 있다.

- length : 배열은 요소의 갯수 = 배열의 길이를 나타내는 length 프로퍼티를 가진다.

- 자바스크립트에 배열은 사실 존재하지 않는다. 배열은 객체타입으로 취급된다. 하지만 다른 언어에 있는 배열을 흉내내서 그럴듯하다.

- 배열과 객체의 차이 : 인덱스 여부(순서를 가지는지 여부), 키와 값 여부, 인덱스를 가지지 않으므로 객체는 length도 가지지 않는다.

- 배열을 만드는 방법

1. 배열 리터럴 : 객체 리터럴과 비슷하게 할당식으로 배열을 만들수 있다.
2. Array 생성자 함수 : 생성자함수로 new를 써서 만들 수 있다.
3. Array.of, Array.from메서드로 만들 수 있다.

- 배열의 장점

1. length 프로퍼티를 가진 배열은 반복문을 돌릴 때 좋다.
2. 배열 메서드를 쓰면 편하다.

### 자바스크립트의 배열은 배열이 아니다

- 자료구조에서 말하는 배열은 밀집배열을 써서 효율적으로 고속으로 동작하는데 자바스크립트에서는 희소배열을 사용해서 비슷하게 만들었을 뿐 사실은 객체다.

- 자바스크립트 배열은 삽입/삭제하는데 특화되어 있고 그냥 배열은 인덱스 검색에 특화되어 있다.

- 그냥 배열은 밀집배열이라서 검색할때 조금더 빠르지만 삽입/삭제와 같은 동작 = 즉 리스트 자체가 변하는 동작일때에는 희소배열을 허용하는 자바스크립트 배열이 성능상으로 우위에 있다.

- 게다가 자바스크립트 배열은 그동한 소소하게 성능 개선에 노력해왔기 때문에 일반 객체보다는 훨씬 성능이 좋긴 하다! 2배는 빠르다.

### 배열 파보기

- length 프로퍼티를 재할당해서 명시적으로 숫자를 바꿔버릴수도 있다.

```js
arr.length = 3;
```

- 만약 현재 length 프로퍼티값보다 작은 값을 할당하면 배열의 길이가 줄어든다.
- 그치만 더 높은 값을 할당해도 늘어나지는 않는다.
- 그건 자바스크립트는 희소배열을 = 배열의 요소가 연속적으로 위치하지 않고 일부가 비어있는 것을 문법적으로 허용하기 때문이다. 자바스크립트는 중간이나 끝이 비어있더라도 빈 값을 위해 따로 메모리공간을 확보하지도 않으며 빈 요소를 생성하지도 않는다.

- 하지만 써서 좋을건 없으니 가능한 length는 알아서 측정되게 하자. 또 배열의 성능을 최대한 끌어내기 위해서는 같은 타입의 요소만 모아서 연속적으로 빈값없이 위치시키는 것이 좋다.

### 배열요소의 참조/추가/갱신

1. 참조 : [] 안에 인덱스를 입력해서 타고타고 간다. 없는 인덱스를 입력하면 undefined가 뜬다. 배열엔 키값이 없는것 같지만 사실 인덱스를 나타내는 문자열이 프로퍼티 키라고 할수 있다.

2. 추가 : 객체처럼 배열에도 리터럴식으로 추가를 할수 있다.

```js
arr[1] = 1;

arr[100] = 1;
// 임의로 배열의 길이보다 큰 숫자를 넣으면 희소배열이 되면서 추가된다.

arr[1] = 3;
// 이미 있는 값에 재할당하면 갱신된다. 객체처럼!

arr["property"] = 1;
// 이렇게 하면 property : 1이 추가된다. 프로퍼티가 추가된다. length를 우회하여 배열에 들어가버리기 때문에 사용에 유의하자.
```

3. 삭제 :

- delete 연산자를 사용해서 삭제할 수 있다. 하지만 이것도 length를 우회하여 객체로서의 특성을 사용하는 것이기 때문에 지양하기
- 배열메서드인 splice 메서드를 사용하면 배열의 방식으로 깔끔하게 삭제할 수 있다.

### 배열메서드

- 편리한 배열메서드가 많다.

1. 원본배열을 직접 변경하는 메서드 = mutator method
2. 원본배열을 놔두고 새로운 배열을 반환하는 메서드 = accessor method

- 당연하게도 2번을 많이 쓰는게 좋다.

- 자주쓰는 메서드

1. Array.isArray : 얘가 배열이면 true, 아니면 false
2. Array.indexOf : 원본배열에서 인수로 전달된 요소를 검색하여 그 인덱스를 반환
3. Array.includes : es7에서 나옴. 인덱스를 주는게 아니라 있는지 없는지를 확인해서 true/false를 반환해주기 때문에 필터링같은거 할때 indexOf에 비해 코드 가독성이 더 좋다.
4. Array.push : 얘는 원본배열을 바꾸므로 조심. push메서드는 성능면에서 그다지 좋지 않은데 배열의 마지막에 뭔가 집어넣고 싶을때는 다음과 같은 코드도 쓸수 있다.

```js
arr[arr.length] = 1;
```

- push와 똑같은 기능이지만 성능이 더 좋다.
- 만약 원본배열을 변경하지 않고 싶다면 spread 문법을 쓰는 것도 좋다.

```js
const newArray = [...arr, 1];
```

- 만약 메서드로 쓰고 싶다면 concat도 방법이다.

```js
const result = arr.concat(arr, 1);
```

5. Array.pop : 얘도 원본배열을 바꿔서 안쓰는게 좋다. 원본배열에서 마지막 요소를 제거하고 제거한 요소를 반환한다. 원본 배열이 빈 배열이면 undefined를 반환한다. push와 pop으로 스택구조를 구현할 수 있다.

6. Array.unshift : 얘도 원본배열... 인수로 전달받은 모든 값을 원본배열의 선두에 요소로 추가하고 변경된 length 프로퍼티값을 변환한다. 마찬가지로 스프레드 문법을 활용하는게 낫다.

```js
const newArray = [1, ...arr];
```

7. Array.shift : 원본배열에서 첫번째 요소를 제거하면서 제거한 요소를 반환한다. 얘는 선입선출의 큐 자료구조를 구현하는데 좋다.

---

8. Array.concat : 인수로 전달된 값을 원본의 마지막 요소로 추가해서 새로운 배열을 반환한다. 전달된 값이 배열일 경우 그 배열을 해체해서 같은 뎁스의 요소로 추가해준다.
   push 쓰지말고 이거 쓰자.

9. Array.splice : 처음이나 마지막이 아닌 중간에서 요소를 추가/제거 하고 싶을때 splice를 사용하면 된다. 원본배열을 직접 변경해버린다.

- splice는 세 개의 매개변수를 사용할 수 있다. 첫번째는 인덱스, 두번째는 제거할 길이(옵션), 세번째는 새로운 요소(옵션)

- 명시적으로 두번째를 0으로 지정해주면 splice는 삭제를 하지 않는다.

9. Array.slice : 인수로 전달된 범위의 요소를 복사하여 배열로 반환한다. 얘는 원본배열을 변환하지 않는다.

- 두개의 매개변수를 갖는다. 첫번째는 복사를 시작할 인덱스, 두번째는 종료할 인덱스(생략하면 끝까지 다 복사한다.)
- 첫번째 매개변수가 음수일 경우 끝에서부터 세어서 첫번째 매개변수의 숫자만큼만 반환한다.
- 모든 인수를 생략하면 원본 배열의 복사본을 반환한다. 이때 복사본은 얕은 복사이므로 주의

10. Array.join : 원본배열의 모든 요소를 문자열로 만들어서, 구분자(지정가능)로 구분된 문자열로 반환한다.

11. Array.reverse : 원본배열이 변경된다. 원본배열을 뒤집는다.

12. Array.fill : 원본배열이 변경된다. 원본배열을 해당 요소로 채워버린다.

- 매개변수는 3개가 들어갈 수 있다.
- 첫번째는 해당요소, 두번째는 시작인덱스, 세번째는 종료인덱스
- fill을 이용해서 뭐가 채워져있는 배열을 생성할 수 있다.

13. Array.flat : 중첩배열을 인수로 전달한 깊이만큼 재귀적으로 평탄화한다.

---

## 27장 배열 ++

### 배열 고차함수

- 고차함수는 함수형 프로그래밍에 기반을 둔 고차원의 - 함수이다. 그래서 고차함수이다.

- 고차함수 : 함수를 인수로 전달받거나 함수를 반환하는 함수
- 함수형 프로그래밍 : 순수함수와 보조함수의 조합을 통해 로직 내에 존재하는 조건문과 반복문, 변수의 사용을 최대한 줄여서 상태변경을 지양하는 프로그래밍.

- 리액트는 함수형 프로그래밍을 지향한다!

- 자바스크립트는 고차함수를 여러개 지원하는데 그중에서도 배열 고차함수는 매우 유용하고 활용도가 높으므로 잘 알아두면 쓸데가 많다.

### 1. sort

- 원본배열을 직접 변경하며 리턴값은 정렬된 배열이다.
- 배열의 요소를 기본적으로는 오름차순으로 정렬하지만 '정렬순서를 정의하는 비교함수'를 인수로 전달하여 정렬 순서를 바꿀 수 있다.

- 함수를 인수로 전달해서 고차함수다!

```js
array.sort((a, b) => a - b);
```

- 비교함수는 양수, 음수, 0 중에 하나를 반환해야 한다. 따라서 이렇게 단순 산술연산으로 정렬할 수 있는건 숫자배열 뿐이다. 문자배열을 조건을 걸어 정렬하고 싶다면 비교연산을 걸어서 리턴값만 1, -1, 0으로 맞춰주면 된다.

- 문자열엔 === 연산자밖에 사용 불가능하다고 생각할수 있지만 사실 문자열에도 대소비교가 가능하다.

- '<', '>' 연산자는 문자열을 '사전 순서' 대로 비교하여 결과를 리턴해준다. 더 정확하게 말하면, 문자열의 ASCII 값을 비교하여 결과를 리턴하는 것이다.

```js
function compare() {
  return (a, b) => (a > b ? 1 : a < b ? -1 : 0);
}
list.sort(compare());
```

- 정렬된 결과에 .reverse를 추가하면 내림차순도 된다.
- 객체를 기준으로 정렬할 경우 비교연산을 사용하여 객체안의 키나 값을 기준으로 정렬할 수 있다.

```js
function compare(key) {
  return (a, b) => (a[key] > b[key] ? 1 : a[key] < b[key] ? -1 : 0);
}
// 이렇게 하고

list.sort(compare("content"));
// 이렇게 하면 키값이 컨텐츠인 애들 안에 있는 값 기준으로 정렬이 된다.
```

- sort 메서드는 팀소트를 쓴다!

### 2. forEach

- for문과 forEach의 차이는 함수형 프로그래밍 방식이냐 아니냐다.
- for문은 로직 안에 조건식과 증감식이 드러나 있고 반복을 위한 초기 변수 또한 따로 설정해주어야 한다는 점에서 함수형 프로그래밍이 추구하는 바와 맞지 않는다.

- forEach 메서드는 for문을 대체하는 고차함수다. 이 메서드 안에 for문이 추상화되어 있어서 계속 반복문을 실행하는 형태이다. forEach는 자신을 호출한 배열을 순회하면서 수행해야 할 처리를 콜백 함수로 전달받아 반복호출한다.

- for문에 비해 특별히 성능이 더 좋거나 한건 아니지만 로직이 숨겨져 있어서 가독성이 좋고 깔끔하다.

```js
list.forEach((item) => console.log(item ** 2));
```

- 그러나 forEach엔 한계점이 있는데, 리턴값이 존재하지 않기 때문에 단순 나열 반복만 되고 뭔가 추가하기가 힘들다는 점이다. 뒤에 나올 map이나 reduce를 쓰면 좋다.

- 그치만 forEach로 배열을 바꾸는게 불가능하진 않다.

```js
// 1번방법. push를 쓴다.
list = [1, 2];
result = [];
list.forEach((item) => result.push(item ** 2));

// 2번방법. 배열리터럴을 쓴다. forEach의 세번째 매개변수는 원본배열 자신이다.
// 원본배열의 해당 인덱스에 새로운 값을 할당하면 덮어쓰게 된다.

list = [1, 2];
list.forEach((item, index, array) => {
  array[index] = item ** 2;
});
```

### 3. map

- 맵은 자신을 호출한 배열의 모든 요소를 순회하면서 인수로 전달받은 콜백함수도 반복호출하고, 그리고 콜백함수의 반환값으로 구성된 새로운 배열까지 반환해준다. 심지어 원본배열은 그대로라서 불변성지킴이이다.

- forEach는 반복문을 대체하기 위한 고차함수이고, map은 요소값을 다른 값으로 mapping한 새 배열을 생성하기 위한 고차함수이다. 상황에 따라서 리턴배열이 굳이 필요없을때는 forEach를 쓰고, 배열을 따로 빼주어야 한다면 map을 쓰자.

- map도 마찬가지로 3가지의 인수를 쓸수 있다. 아이템, 인덱스, 원본배열!

- 리액트 하면서 가장 많이 쓰는 함수

### 4. filter

- 필터는 자신을 호출한 배열의 모든 요소를 순회하면서 인수로 전달받은 콜백함수도 반복호출하고, 그리고 콜백함수의 반환값이 true인 요소로만 구성된 새로운 배열까지 반환해준다. 얘도 원본배열이 그대로라서 불변성지킴이이다.

- 맵과의 차이점은 true만 모아 반환해준다는 점이다.

- 리액트 하면서 두번째로 많이 쓰는 함수

- 필터도 마찬가지로 3가지의 인수를 쓸수 있다. 아이템, 인덱스, 원본배열!

- 필터 메서드는 자신을 호출한 배열에서 필터링 조건을 만족하는 특정 요소만 추출하여 새로운 배열을 만들고 싶을때 사용한다.

- !== 부정논리연산자를 쓰면 필터링 조건에 만족하지 못하는 요소만 걸러낼수도 있다.

### 5. reduce

- 리듀스는 자신을 호출한 배열의 모든 요소를 순회하며 인수로 전달받은 콜백함수를 반복호출한다. 그리고 그 콜백함수의 반환값을 다음 순회시에 콜백함수의 첫번째 인수로 전달하면서 콜백함수를 호출하여 하나의 결과값을 만들어 리턴한다.

- 리듀스는 쓰기 좀 헷갈리지만 잘 쓰면 무척 강력한 메서드이다.

- 리듀스는 첫번째로 콜백함수, 두번째로 초기값, 세번째로 인덱스, 네번째로 원본배열을 받는다.

- 리듀스의 콜백함수에는 4개의 인수(초기값 또는 콜백함수의 이전 반환값, 배열의 해당번째 요소값, 배열의 해당 인덱스, 원본배열(this))가 전달된다.
