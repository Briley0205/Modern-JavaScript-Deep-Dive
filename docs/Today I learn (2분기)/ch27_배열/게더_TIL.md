## 📕 오늘 공부한 내용, 이렇게 정리해 봅시다. ✒

**TIL(Today I learn) 기록일** : 2022.08.26 - 28

**오늘 읽은 범위** : 27장 배열

### 배열이란 📑

- 배열 array는 여러개의 값을 순차적으로 나열한 자료구조이다. 배열은 사용빈도가 매우 높으며 자바스크립트에서는 배열 전용 메서드도 여러개 제공한다. 배열 메서드를 능숙하게 다루면 코딩에 매우 도움이 된다.

- 요소(element) : 배열은 대괄호 안 각 요소들로 구성되는데 이때 요소는 자바스크립트에 존재하는 어떤 형태의 값이라도 될 수 있다.

- 인덱스 : 배열 내의 모든 값은 배열 내에서 자신의 위치를 나타내는 0 이상의 정수인 인덱스 값을 갖는다. 대괄호 표기법으로 각 요소에 접근할 수 있다.

- length : 배열은 요소의 갯수 = 배열의 길이를 나타내는 length 프로퍼티를 가진다.

- 자바스크립트에 배열은 사실 존재하지 않는다. 배열은 객체타입으로 취급된다. 하지만 다른 언어에 있는 배열을 흉내내서 그럴듯하다.

- 배열과 객체의 차이 : 인덱스 여부(순서를 가지는지 여부), 키와 값 여부, 인덱스를 가지지 않으므로 객체는 length도 가지지 않는다.

- 배열을 만드는 방법

1. 배열 리터럴 : 객체 리터럴과 비슷하게 할당식으로 배열을 만들수 있다.
2. Array 생성자 함수 : 생성자함수로 new를 써서 만들 수 있다.
3. Array.of, Array.from메서드로 만들 수 있다.

- 배열의 장점

1. length 프로퍼티를 가진 배열은 반복문을 돌릴 때 좋다.
2. 배열 메서드를 쓰면 편하다.

### 자바스크립트의 배열은 배열이 아니다

- 자료구조에서 말하는 배열은 밀집배열을 써서 효율적으로 고속으로 동작하는데 자바스크립트에서는 희소배열을 사용해서 비슷하게 만들었을 뿐 사실은 객체다.

- 자바스크립트 배열은 삽입/삭제하는데 특화되어 있고 그냥 배열은 인덱스 검색에 특화되어 있다.

- 그냥 배열은 밀집배열이라서 검색할때 조금더 빠르지만 삽입/삭제와 같은 동작 = 즉 리스트 자체가 변하는 동작일때에는 희소배열을 허용하는 자바스크립트 배열이 성능상으로 우위에 있다.

- 게다가 자바스크립트 배열은 그동한 소소하게 성능 개선에 노력해왔기 때문에 일반 객체보다는 훨씬 성능이 좋긴 하다! 2배는 빠르다.

### 배열 파보기

- length 프로퍼티를 재할당해서 명시적으로 숫자를 바꿔버릴수도 있다.

```js
arr.length = 3;
```

- 만약 현재 length 프로퍼티값보다 작은 값을 할당하면 배열의 길이가 줄어든다.
- 그치만 더 높은 값을 할당해도 늘어나지는 않는다.
- 그건 자바스크립트는 희소배열을 = 배열의 요소가 연속적으로 위치하지 않고 일부가 비어있는 것을 문법적으로 허용하기 때문이다. 자바스크립트는 중간이나 끝이 비어있더라도 빈 값을 위해 따로 메모리공간을 확보하지도 않으며 빈 요소를 생성하지도 않는다.

- 하지만 써서 좋을건 없으니 가능한 length는 알아서 측정되게 하자. 또 배열의 성능을 최대한 끌어내기 위해서는 같은 타입의 요소만 모아서 연속적으로 빈값없이 위치시키는 것이 좋다.

### 배열요소의 참조/추가/갱신

1. 참조 : [] 안에 인덱스를 입력해서 타고타고 간다. 없는 인덱스를 입력하면 undefined가 뜬다. 배열엔 키값이 없는것 같지만 사실 인덱스를 나타내는 문자열이 프로퍼티 키라고 할수 있다.

2. 추가 : 객체처럼 배열에도 리터럴식으로 추가를 할수 있다.

```js
arr[1] = 1;

arr[100] = 1;
// 임의로 배열의 길이보다 큰 숫자를 넣으면 희소배열이 되면서 추가된다.

arr[1] = 3;
// 이미 있는 값에 재할당하면 갱신된다. 객체처럼!

arr["property"] = 1;
// 이렇게 하면 property : 1이 추가된다. 프로퍼티가 추가된다. length를 우회하여 배열에 들어가버리기 때문에 사용에 유의하자.
```

3. 삭제 :

- delete 연산자를 사용해서 삭제할 수 있다. 하지만 이것도 length를 우회하여 객체로서의 특성을 사용하는 것이기 때문에 지양하기
- 배열메서드인 splice 메서드를 사용하면 배열의 방식으로 깔끔하게 삭제할 수 있다.

### 배열메서드

- 편리한 배열메서드가 많다.

1. 원본배열을 직접 변경하는 메서드 = mutator method
2. 원본배열을 놔두고 새로운 배열을 반환하는 메서드 = accessor method

- 당연하게도 2번을 많이 쓰는게 좋다.

- 자주쓰는 메서드

1. Array.isArray : 얘가 배열이면 true, 아니면 false
2. Array.indexOf : 원본배열에서 인수로 전달된 요소를 검색하여 그 인덱스를 반환
3. Array.includes : es7에서 나옴. 인덱스를 주는게 아니라 있는지 없는지를 확인해서 true/false를 반환해주기 때문에 필터링같은거 할때 indexOf에 비해 코드 가독성이 더 좋다.
4. Array.push : 얘는 원본배열을 바꾸므로 조심. push메서드는 성능면에서 그다지 좋지 않은데 배열의 마지막에 뭔가 집어넣고 싶을때는 다음과 같은 코드도 쓸수 있다.

```js
arr[arr.length] = 1;
```

- push와 똑같은 기능이지만 성능이 더 좋다.
- 만약 원본배열을 변경하지 않고 싶다면 spread 문법을 쓰는 것도 좋다.

```js
const newArray = [...arr, 1];
```

- 만약 메서드로 쓰고 싶다면 concat도 방법이다.

```js
const result = arr.concat(arr, 1);
```

5. Array.pop : 얘도 원본배열을 바꿔서 안쓰는게 좋다. 원본배열에서 마지막 요소를 제거하고 제거한 요소를 반환한다. 원본 배열이 빈 배열이면 undefined를 반환한다. push와 pop으로 스택구조를 구현할 수 있다.

6. Array.unshift : 얘도 원본배열... 인수로 전달받은 모든 값을 원본배열의 선두에 요소로 추가하고 변경된 length 프로퍼티값을 변환한다. 마찬가지로 스프레드 문법을 활용하는게 낫다.

```js
const newArray = [1, ...arr];
```

7. Array.shift : 원본배열에서 첫번째 요소를 제거하면서 제거한 요소를 반환한다. 얘는 선입선출의 큐 자료구조를 구현하는데 좋다.

---

8. Array.concat : 인수로 전달된 값을 원본의 마지막 요소로 추가해서 새로운 배열을 반환한다. 전달된 값이 배열일 경우 그 배열을 해체해서 같은 뎁스의 요소로 추가해준다.
   push 쓰지말고 이거 쓰자.

9. Array.splice : 처음이나 마지막이 아닌 중간에서 요소를 추가/제거 하고 싶을때 splice를 사용하면 된다. 원본배열을 직접 변경해버린다.

- splice는 세 개의 매개변수를 사용할 수 있다. 첫번째는 인덱스, 두번째는 제거할 길이(옵션), 세번째는 새로운 요소(옵션)

- 명시적으로 두번째를 0으로 지정해주면 splice는 삭제를 하지 않는다.

9. Array.slice : 인수로 전달된 범위의 요소를 복사하여 배열로 반환한다. 얘는 원본배열을 변환하지 않는다.

- 두개의 매개변수를 갖는다. 첫번째는 복사를 시작할 인덱스, 두번째는 종료할 인덱스(생략하면 끝까지 다 복사한다.)
- 첫번째 매개변수가 음수일 경우 끝에서부터 세어서 첫번째 매개변수의 숫자만큼만 반환한다.
- 모든 인수를 생략하면 원본 배열의 복사본을 반환한다. 이때 복사본은 얕은 복사이므로 주의

10. Array.join : 원본배열의 모든 요소를 문자열로 만들어서, 구분자(지정가능)로 구분된 문자열로 반환한다.

11. Array.reverse : 원본배열이 변경된다. 원본배열을 뒤집는다.

12. Array.fill : 원본배열이 변경된다. 원본배열을 해당 요소로 채워버린다.

- 매개변수는 3개가 들어갈 수 있다.
- 첫번째는 해당요소, 두번째는 시작인덱스, 세번째는 종료인덱스
- fill을 이용해서 뭐가 채워져있는 배열을 생성할 수 있다.

13. Array.flat : 중첩배열을 인수로 전달한 깊이만큼 재귀적으로 평탄화한다.

### 배열 고차함수

- 를 쓰려고 했지만 너무 길어져서...
- 월요일것 짧을 것 같으니 거기에 같이 쓰겠습니다!
